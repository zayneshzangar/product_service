cmd/main.go
------------------------------
package main

import (
	"log"
	"net/http"
	"os"

	"product_service/internal/delivery/grpc"
	"product_service/internal/delivery/rest"
	"product_service/internal/repository"
	"product_service/internal/usecase"

	_ "github.com/lib/pq"
)

// func main() {
// 	// Загружаем .env
// 	// if err := godotenv.Load(); err != nil {
// 	// 	log.Fatal("Error loading .env file")
// 	// }

// 	// Выбираем базу данных
// 	dbType := repository.DatabaseType(os.Getenv("DB_TYPE"))
// 	repo, err := repository.NewDatabaseConnection(dbType)
// 	if err != nil {
// 		log.Fatal("Error creating repository: ", err)
// 	}

// 	// Создаём usecase
// 	productUseCase := usecase.NewProductUseCase(repo)

// 	// Создаём REST handler
// 	productHandler := rest.NewProductHandler(productUseCase)

// 	// Создаём роутер и запускаем сервер
// 	router := rest.NewRouter(productHandler)
// 	port := ":8080"
// 	log.Println("Starting server on", port)
// 	log.Fatal(http.ListenAndServe(port, router))
// }

func main() {
	// Загружаем .env
	// if err := godotenv.Load(); err != nil {
	// 	log.Fatal("Error loading .env file")
	// }

	dbType := repository.DatabaseType(os.Getenv("DB_TYPE"))
	repo, err := repository.NewDatabaseConnection(dbType)
	if err != nil {
		log.Fatal("Error creating repository: ", err)
	}

	productRepo := repository.NewPostgresProductRepository(repo)
	productUseCase := usecase.NewProductUseCase(productRepo)

	// Запускаем REST API
	productHandler := rest.NewProductHandler(productUseCase)
	router := rest.NewRouter(productHandler)

	// Запускаем gRPC сервер в отдельной горутине
	go grpc.StartGRPCServer(productUseCase)

	port := ":8080"
	log.Println("Starting REST API server on", port)
	log.Fatal(http.ListenAndServe(port, router))
}

internal/delivery/grpc/server.go
--------------------------------
package grpc

import (
	"context"
	"log"
	"net"

	pb "product_service/internal/productpb"
	"product_service/internal/usecase"

	"google.golang.org/grpc"
)

type GRPCServer struct {
	pb.UnimplementedProductServiceServer
	useCase usecase.ProductUseCase
}

func NewGRPCServer(useCase usecase.ProductUseCase) *GRPCServer {
	return &GRPCServer{useCase: useCase}
}

func (s *GRPCServer) CheckAndReserveStock(ctx context.Context, req *pb.StockReservationRequest) (*pb.StockReservationResponse, error) {
	return s.useCase.CheckAndReserveStock(ctx, req)
}

func StartGRPCServer(useCase usecase.ProductUseCase) {
	lis, err := net.Listen("tcp", ":50051")
	if err != nil {
		log.Fatalf("Failed to listen: %v", err)
	}

	grpcServer := grpc.NewServer()
	pb.RegisterProductServiceServer(grpcServer, NewGRPCServer(useCase))

	log.Println("gRPC Server is running on port 50051...")
	if err := grpcServer.Serve(lis); err != nil {
		log.Fatalf("Failed to serve: %v", err)
	}
}

internal/delivery/rest/product_hundler.go
-------------------------
package rest

import (
	"encoding/json"
	"net/http"
	"product_service/internal/entity"
	"product_service/internal/usecase"
	"strconv"

	"github.com/gorilla/mux"
)

// ProductHandler отвечает за обработку REST-запросов
type ProductHandler struct {
	productUseCase usecase.ProductUseCase
}

// NewProductHandler создаёт новый обработчик
func NewProductHandler(productUseCase usecase.ProductUseCase) *ProductHandler {
	return &ProductHandler{productUseCase: productUseCase}
}

// CreateProductHandler — обработчик для создания продукта
func (h *ProductHandler) CreateProductHandler(w http.ResponseWriter, r *http.Request) {
	var req struct {
		Name        string  `json:"name"`
		Description string  `json:"description"`
		Price       float64 `json:"price"`
		Stock       int     `json:"stock"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "invalid request", http.StatusBadRequest)
		return
	}

	product, err := h.productUseCase.CreateProduct(req.Name, req.Description, req.Price, req.Stock)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(product)
}

// GetProductByIDHandler — обработчик для получения продукта по ID
func (h *ProductHandler) GetProductByIDHandler(w http.ResponseWriter, r *http.Request) {
	// Получаем ID из URL
	vars := mux.Vars(r)
	idStr, ok := vars["id"]
	if !ok {
		http.Error(w, "missing product ID", http.StatusBadRequest)
		return
	}

	// Конвертируем строку в int64
	id, err := strconv.ParseInt(idStr, 10, 64)
	if err != nil {
		http.Error(w, "invalid product ID", http.StatusBadRequest)
		return
	}

	// Получаем продукт из usecase
	product, err := h.productUseCase.GetProductByID(id)
	if err != nil {
		http.Error(w, "product not found", http.StatusNotFound)
		return
	}

	// Отправляем ответ в JSON
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(product)
}

// GetAllProductsHandler — обработчик для получения всех продуктов
func (h *ProductHandler) GetAllProductsHandler(w http.ResponseWriter, r *http.Request) {
	products, err := h.productUseCase.GetAllProducts()
	if err != nil {
		http.Error(w, "failed to fetch products", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(products)
}

// UpdateProductHandler — обновление товара по ID
func (h *ProductHandler) UpdateProductHandler(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	idStr, ok := vars["id"]
	if !ok {
		http.Error(w, "missing product ID", http.StatusBadRequest)
		return
	}

	id, err := strconv.ParseInt(idStr, 10, 64)
	if err != nil {
		http.Error(w, "invalid product ID", http.StatusBadRequest)
		return
	}

	var product entity.Product
	err = json.NewDecoder(r.Body).Decode(&product)
	if err != nil {
		http.Error(w, "invalid request body", http.StatusBadRequest)
		return
	}
	product.ID = id // Устанавливаем ID из URL

	err = h.productUseCase.UpdateProduct(&product)
	if err != nil {
		http.Error(w, "failed to update product", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(map[string]string{"message": "product updated successfully"})
}

// DeleteProductHandler — удаление товара по ID
func (h *ProductHandler) DeleteProductHandler(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	idStr, ok := vars["id"]
	if !ok {
		http.Error(w, "missing product ID", http.StatusBadRequest)
		return
	}

	id, err := strconv.ParseInt(idStr, 10, 64)
	if err != nil {
		http.Error(w, "invalid product ID", http.StatusBadRequest)
		return
	}

	err = h.productUseCase.DeleteProduct(id)
	if err != nil {
		http.Error(w, "failed to delete product", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(map[string]string{"message": "product deleted successfully"})
}

internal/delivery/rest/router.go
---------------------------
package rest

import (
	"github.com/gorilla/mux"
)

func NewRouter(productHandler *ProductHandler) *mux.Router {
	r := mux.NewRouter()
	r.HandleFunc("/products", productHandler.CreateProductHandler).Methods("POST")
	r.HandleFunc("/products", productHandler.GetAllProductsHandler).Methods("GET")
	r.HandleFunc("/products/{id}", productHandler.GetProductByIDHandler).Methods("GET")
	r.HandleFunc("/products/{id}", productHandler.UpdateProductHandler).Methods("PUT")    // <-- Добавили обновление
	r.HandleFunc("/products/{id}", productHandler.DeleteProductHandler).Methods("DELETE") // <-- Добавили удаление
	return r
}

internal/usecase/product_usecase.go
-------------------------
package usecase

import (
	"context"
	"errors"
	"fmt"
	"time"

	"product_service/internal/entity"
	pb "product_service/internal/productpb"
	"product_service/internal/repository"
)

// ProductUseCase — интерфейс бизнес-логики
type ProductUseCase interface {
	CreateProduct(name, description string, price float64, stock int) (*entity.Product, error)
	GetProductByID(id int64) (*entity.Product, error)
	GetAllProducts() ([]*entity.Product, error)
	UpdateProduct(product *entity.Product) error
	DeleteProduct(id int64) error
	CheckAndReserveStock(ctx context.Context, req *pb.StockReservationRequest) (*pb.StockReservationResponse, error)
}

// productUseCase — реализация use case
type productUseCase struct {
	productRepo repository.ProductRepository
}

// NewProductUseCase создает новый use case
func NewProductUseCase(productRepo repository.ProductRepository) ProductUseCase {
	return &productUseCase{productRepo: productRepo} // ВОЗВРАЩАЕМ УКАЗАТЕЛЬ
}

// CreateProduct создает новый продукт
func (u *productUseCase) CreateProduct(name, description string, price float64, stock int) (*entity.Product, error) {
	if name == "" || price <= 0 || stock < 0 {
		return nil, errors.New("invalid product data")
	}

	product := &entity.Product{
		Name:        name,
		Description: description,
		Price:       price,
		Stock:       stock,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}

	err := u.productRepo.Create(product)
	if err != nil {
		return nil, err
	}
	return product, nil
}

// GetProductByID получает продукт по ID
func (u *productUseCase) GetProductByID(id int64) (*entity.Product, error) {
	return u.productRepo.GetByID(id)
}

// GetAllProducts получает все продукты
func (u *productUseCase) GetAllProducts() ([]*entity.Product, error) {
	return u.productRepo.GetAll()
}

// UpdateProduct обновляет продукт
func (u *productUseCase) UpdateProduct(product *entity.Product) error {
	if product.ID == 0 {
		return errors.New("invalid product ID")
	}
	product.UpdatedAt = time.Now()
	return u.productRepo.Update(product)
}

// DeleteProduct удаляет продукт
func (u *productUseCase) DeleteProduct(id int64) error {
	return u.productRepo.Delete(id)
}

func (u *productUseCase) CheckAndReserveStock(ctx context.Context, req *pb.StockReservationRequest) (*pb.StockReservationResponse, error) {
	// Открываем транзакцию
	tx, err := u.productRepo.BeginTransaction()
	if err != nil {
		return &pb.StockReservationResponse{Success: false, Message: "DB transaction error"}, err
	}
	defer tx.Rollback()

	for _, item := range req.Items {
		product, err := u.productRepo.GetProductByID(ctx, item.ProductId)
		if err != nil {
			return &pb.StockReservationResponse{Success: false, Message: fmt.Sprintf("Product %d not found", item.ProductId)}, nil
		}

		if product.Stock < int(item.Quantity) {
			return &pb.StockReservationResponse{Success: false, Message: fmt.Sprintf("Not enough stock for product %d", item.ProductId)}, nil
		}

		err = u.productRepo.UpdateStock(ctx, tx, item.ProductId, -int(item.Quantity))
		if err != nil {
			return &pb.StockReservationResponse{Success: false, Message: "Failed to update stock"}, err
		}

		err = u.productRepo.ReserveStock(ctx, tx, req.OrderId, item.ProductId, int(item.Quantity))
		if err != nil {
			return &pb.StockReservationResponse{Success: false, Message: "Failed to reserve stock"}, err
		}
	}

	// Фиксируем транзакцию
	if err := tx.Commit(); err != nil {
		return &pb.StockReservationResponse{Success: false, Message: "Transaction commit failed"}, err
	}

	return &pb.StockReservationResponse{Success: true, Message: "Stock reserved successfully"}, nil
}

internal/repository/factory.go
-------------------------------
package repository

import (
	"database/sql"
	"fmt"
	"os"

	_ "github.com/lib/pq"
)

// DatabaseType определяет доступные базы данных
type DatabaseType string

const (
	Postgres DatabaseType = "postgres"
	Mongo    DatabaseType = "mongo"
)

// NewDatabaseConnection устанавливает соединение с базой данных
func NewDatabaseConnection(dbType DatabaseType) (ProductRepository, error) {
	switch dbType {
	case Postgres:
		return NewPostgresRepository()
	// case Mongo:
	// 	return NewMongoRepository() // Когда добавишь Mongo
	default:
		return nil, fmt.Errorf("unsupported database type: %s", dbType)
	}
}

// NewPostgresRepository создает подключение к Postgres
func NewPostgresRepository() (ProductRepository, error) {
	connStr := fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=%s",
		os.Getenv("USER_PRODUCT_SERVICE"),
		os.Getenv("PASSWORD_PRODUCT_SERVICE"),
		os.Getenv("DB_HOST"),
		os.Getenv("DB_PORT"),
		os.Getenv("DB_PRODUCT_SERVICE"),
		os.Getenv("DB_SSLMODE"),
	)
	db, err := sql.Open("postgres", connStr)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to database: %v", err)
	}

	err = db.Ping()
	if err != nil {
		return nil, fmt.Errorf("failed to ping database: %v", err)
	}

	return &PostgresProductRepository{db: db}, nil
}

internal/repository/postgres_product_repository.go
------------------------
package repository

import (
	"context"
	"database/sql"
	"errors"
	"product_service/internal/entity"
)

// PostgresProductRepository реализует интерфейс ProductRepository для Postgres
type PostgresProductRepository struct {
	db *sql.DB
}

// NewPostgresProductRepository создаёт новый Postgres-репозиторий
func NewPostgresProductRepository(db *sql.DB) ProductRepository {
	return &PostgresProductRepository{db: db}
}

// Методы работы с продуктами

func (r *PostgresProductRepository) Create(product *entity.Product) error {
	_, err := r.db.Exec("INSERT INTO products (name, description, price, stock) VALUES ($1, $2, $3, $4)",
		product.Name, product.Description, product.Price, product.Stock)
	return err
}

func (r *PostgresProductRepository) GetByID(id int64) (*entity.Product, error) {
	var product entity.Product
	err := r.db.QueryRow("SELECT id, name, description, price, stock FROM products WHERE id=$1", id).
		Scan(&product.ID, &product.Name, &product.Description, &product.Price, &product.Stock)
	return &product, err
}

func (r *PostgresProductRepository) GetAll() ([]*entity.Product, error) {
	rows, err := r.db.Query("SELECT id, name, description, price, stock FROM products")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var products []*entity.Product
	for rows.Next() {
		var product entity.Product
		err := rows.Scan(&product.ID, &product.Name, &product.Description, &product.Price, &product.Stock)
		if err != nil {
			return nil, err
		}
		products = append(products, &product)
	}
	return products, nil
}

func (r *PostgresProductRepository) Update(product *entity.Product) error {
	_, err := r.db.Exec("UPDATE products SET name=$1, description=$2, price=$3, stock=$4 WHERE id=$5",
		product.Name, product.Description, product.Price, product.Stock, product.ID)
	return err
}

func (r *PostgresProductRepository) Delete(id int64) error {
	_, err := r.db.Exec("DELETE FROM products WHERE id=$1", id)
	return err
}


// STOCK methods
func (r *PostgresProductRepository) BeginTransaction() (*sql.Tx, error) {
	return r.db.Begin()
}

func (r *PostgresProductRepository) GetProductByID(ctx context.Context, productID int64) (*entity.Product, error) {
	product := &entity.Product{}
	err := r.db.QueryRowContext(ctx, "SELECT id, stock FROM products WHERE id = $1", productID).
		Scan(&product.ID, &product.Stock)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, err
		}
		return nil, err
	}
	return product, nil
}

func (r *PostgresProductRepository) UpdateStock(ctx context.Context, tx *sql.Tx, productID int64, quantityChange int) error {
	_, err := tx.ExecContext(ctx, "UPDATE products SET stock = stock + $1 WHERE id = $2", quantityChange, productID)
	return err
}

func (r *PostgresProductRepository) ReserveStock(ctx context.Context, tx *sql.Tx, orderID, productID int64, quantity int) error {
	_, err := tx.ExecContext(ctx, "INSERT INTO reserved_stock (order_id, product_id, quantity) VALUES ($1, $2, $3)", orderID, productID, quantity)
	return err
}

internal/repository/product_repository.go
---------------------------------
package repository

import (
	"context"
	"database/sql"
	"product_service/internal/entity"
)

// ProductRepository — интерфейс для работы с продуктами
type ProductRepository interface {
	Create(product *entity.Product) error
	GetByID(id int64) (*entity.Product, error)
	GetAll() ([]*entity.Product, error)
	Update(product *entity.Product) error
	Delete(id int64) error
	BeginTransaction() (*sql.Tx, error)
	GetProductByID(ctx context.Context, productID int64) (*entity.Product, error)
	UpdateStock(ctx context.Context, tx *sql.Tx, productID int64, quantityChange int) error
	ReserveStock(ctx context.Context, tx *sql.Tx, orderID, productID int64, quantity int) error
}


internal/entity/product.go
----------------------
package entity

import "time"

// Product представляет сущность товара
type Product struct {
    ID          int64     `json:"id"`
    Name        string    `json:"name"`
    Description string    `json:"description"`
    Price       float64   `json:"price"`
    Stock       int       `json:"stock"`
    CreatedAt   time.Time `json:"created_at"`
    UpdatedAt   time.Time `json:"updated_at"`
}


internal/productpb/product_grpc.pb.go
-------------------------------------
// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.19.6
// source: proto/product.proto

package productpb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ProductService_CheckAndReserveStock_FullMethodName = "/product.ProductService/CheckAndReserveStock"
)

// ProductServiceClient is the client API for ProductService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Определяем сервис ProductService
type ProductServiceClient interface {
	CheckAndReserveStock(ctx context.Context, in *StockReservationRequest, opts ...grpc.CallOption) (*StockReservationResponse, error)
}

type productServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProductServiceClient(cc grpc.ClientConnInterface) ProductServiceClient {
	return &productServiceClient{cc}
}

func (c *productServiceClient) CheckAndReserveStock(ctx context.Context, in *StockReservationRequest, opts ...grpc.CallOption) (*StockReservationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StockReservationResponse)
	err := c.cc.Invoke(ctx, ProductService_CheckAndReserveStock_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProductServiceServer is the server API for ProductService service.
// All implementations must embed UnimplementedProductServiceServer
// for forward compatibility.
//
// Определяем сервис ProductService
type ProductServiceServer interface {
	CheckAndReserveStock(context.Context, *StockReservationRequest) (*StockReservationResponse, error)
	mustEmbedUnimplementedProductServiceServer()
}

// UnimplementedProductServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedProductServiceServer struct{}

func (UnimplementedProductServiceServer) CheckAndReserveStock(context.Context, *StockReservationRequest) (*StockReservationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckAndReserveStock not implemented")
}
func (UnimplementedProductServiceServer) mustEmbedUnimplementedProductServiceServer() {}
func (UnimplementedProductServiceServer) testEmbeddedByValue()                        {}

// UnsafeProductServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProductServiceServer will
// result in compilation errors.
type UnsafeProductServiceServer interface {
	mustEmbedUnimplementedProductServiceServer()
}

func RegisterProductServiceServer(s grpc.ServiceRegistrar, srv ProductServiceServer) {
	// If the following call pancis, it indicates UnimplementedProductServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ProductService_ServiceDesc, srv)
}

func _ProductService_CheckAndReserveStock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StockReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).CheckAndReserveStock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProductService_CheckAndReserveStock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).CheckAndReserveStock(ctx, req.(*StockReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ProductService_ServiceDesc is the grpc.ServiceDesc for ProductService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProductService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "product.ProductService",
	HandlerType: (*ProductServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CheckAndReserveStock",
			Handler:    _ProductService_CheckAndReserveStock_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/product.proto",
}


internal/productpb/product.pb.go
------------------------------------
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.5
// 	protoc        v3.19.6
// source: proto/product.proto

package productpb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Запрос на проверку и резервирование товаров
type StockReservationRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	OrderId       int64                  `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	Items         []*OrderItem           `protobuf:"bytes,2,rep,name=items,proto3" json:"items,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StockReservationRequest) Reset() {
	*x = StockReservationRequest{}
	mi := &file_proto_product_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StockReservationRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StockReservationRequest) ProtoMessage() {}

func (x *StockReservationRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_product_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StockReservationRequest.ProtoReflect.Descriptor instead.
func (*StockReservationRequest) Descriptor() ([]byte, []int) {
	return file_proto_product_proto_rawDescGZIP(), []int{0}
}

func (x *StockReservationRequest) GetOrderId() int64 {
	if x != nil {
		return x.OrderId
	}
	return 0
}

func (x *StockReservationRequest) GetItems() []*OrderItem {
	if x != nil {
		return x.Items
	}
	return nil
}

// Ответ от Product Service
type StockReservationResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StockReservationResponse) Reset() {
	*x = StockReservationResponse{}
	mi := &file_proto_product_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StockReservationResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StockReservationResponse) ProtoMessage() {}

func (x *StockReservationResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_product_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StockReservationResponse.ProtoReflect.Descriptor instead.
func (*StockReservationResponse) Descriptor() ([]byte, []int) {
	return file_proto_product_proto_rawDescGZIP(), []int{1}
}

func (x *StockReservationResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *StockReservationResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// Элемент заказа
type OrderItem struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ProductId     int64                  `protobuf:"varint,1,opt,name=product_id,json=productId,proto3" json:"product_id,omitempty"`
	Quantity      int32                  `protobuf:"varint,2,opt,name=quantity,proto3" json:"quantity,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OrderItem) Reset() {
	*x = OrderItem{}
	mi := &file_proto_product_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OrderItem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OrderItem) ProtoMessage() {}

func (x *OrderItem) ProtoReflect() protoreflect.Message {
	mi := &file_proto_product_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OrderItem.ProtoReflect.Descriptor instead.
func (*OrderItem) Descriptor() ([]byte, []int) {
	return file_proto_product_proto_rawDescGZIP(), []int{2}
}

func (x *OrderItem) GetProductId() int64 {
	if x != nil {
		return x.ProductId
	}
	return 0
}

func (x *OrderItem) GetQuantity() int32 {
	if x != nil {
		return x.Quantity
	}
	return 0
}

var File_proto_product_proto protoreflect.FileDescriptor

var file_proto_product_proto_rawDesc = string([]byte{
	0x0a, 0x13, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x07, 0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x22, 0x5e,
	0x0a, 0x17, 0x53, 0x74, 0x6f, 0x63, 0x6b, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x19, 0x0a, 0x08, 0x6f, 0x72, 0x64,
	0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x07, 0x6f, 0x72, 0x64,
	0x65, 0x72, 0x49, 0x64, 0x12, 0x28, 0x0a, 0x05, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x18, 0x02, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x2e, 0x4f, 0x72,
	0x64, 0x65, 0x72, 0x49, 0x74, 0x65, 0x6d, 0x52, 0x05, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x22, 0x4e,
	0x0a, 0x18, 0x53, 0x74, 0x6f, 0x63, 0x6b, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x75,
	0x63, 0x63, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x73, 0x75, 0x63,
	0x63, 0x65, 0x73, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x46,
	0x0a, 0x09, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x74, 0x65, 0x6d, 0x12, 0x1d, 0x0a, 0x0a, 0x70,
	0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52,
	0x09, 0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x49, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x71, 0x75,
	0x61, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x71, 0x75,
	0x61, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x32, 0x6d, 0x0a, 0x0e, 0x50, 0x72, 0x6f, 0x64, 0x75, 0x63,
	0x74, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x5b, 0x0a, 0x14, 0x43, 0x68, 0x65, 0x63,
	0x6b, 0x41, 0x6e, 0x64, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x53, 0x74, 0x6f, 0x63, 0x6b,
	0x12, 0x20, 0x2e, 0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x2e, 0x53, 0x74, 0x6f, 0x63, 0x6b,
	0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x1a, 0x21, 0x2e, 0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x2e, 0x53, 0x74, 0x6f,
	0x63, 0x6b, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x14, 0x5a, 0x12, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61,
	0x6c, 0x2f, 0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x70, 0x62, 0x62, 0x06, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x33,
})

var (
	file_proto_product_proto_rawDescOnce sync.Once
	file_proto_product_proto_rawDescData []byte
)

func file_proto_product_proto_rawDescGZIP() []byte {
	file_proto_product_proto_rawDescOnce.Do(func() {
		file_proto_product_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_product_proto_rawDesc), len(file_proto_product_proto_rawDesc)))
	})
	return file_proto_product_proto_rawDescData
}

var file_proto_product_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_proto_product_proto_goTypes = []any{
	(*StockReservationRequest)(nil),  // 0: product.StockReservationRequest
	(*StockReservationResponse)(nil), // 1: product.StockReservationResponse
	(*OrderItem)(nil),                // 2: product.OrderItem
}
var file_proto_product_proto_depIdxs = []int32{
	2, // 0: product.StockReservationRequest.items:type_name -> product.OrderItem
	0, // 1: product.ProductService.CheckAndReserveStock:input_type -> product.StockReservationRequest
	1, // 2: product.ProductService.CheckAndReserveStock:output_type -> product.StockReservationResponse
	2, // [2:3] is the sub-list for method output_type
	1, // [1:2] is the sub-list for method input_type
	1, // [1:1] is the sub-list for extension type_name
	1, // [1:1] is the sub-list for extension extendee
	0, // [0:1] is the sub-list for field type_name
}

func init() { file_proto_product_proto_init() }
func file_proto_product_proto_init() {
	if File_proto_product_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_product_proto_rawDesc), len(file_proto_product_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   3,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_proto_product_proto_goTypes,
		DependencyIndexes: file_proto_product_proto_depIdxs,
		MessageInfos:      file_proto_product_proto_msgTypes,
	}.Build()
	File_proto_product_proto = out.File
	file_proto_product_proto_goTypes = nil
	file_proto_product_proto_depIdxs = nil
}
